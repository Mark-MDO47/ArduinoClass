/// @file    Blink.ino
/// @brief   Blink the first LED of an LED strip
/// @example Blink.ino

/*
 * Modified by Mark Olson for his Arduino class https://github.com/Mark-MDO47/ArduinoClass
 * 
 * We are using an Arduino Nano with a USB mini-B connector
 *            V3.0 ATmega328P 5V 16M CH340 Compatible to Arduino Nano V3
 *            32Kbyte Flash (program storage), 2Kbyte SRAM, 1Kbyte EEPROM
 *            http://www.mouser.com/pdfdocs/Gravitech_Arduino_Nano3_0.pdf
 *            http://www.pighixxx.com/test/pinouts/boards/nano.pdf
 *
 * https://github.com/Mark-MDO47/ArduinoClass/tree/master/03_SonarRangeDetector
 * 
 * Voice Commands
 */

 // connections:
// 
// Nano pin 5V      LEDstick VCC
// Nano pin GND     LEDstick GND
// Nano pin D-7     LEDstick DIN
//
// These are definitions for the DFRobot SKU DF2301QG-EN from the Gravity product line
//     voice command module
//   https://www.dfrobot.com/product-2665.html
//   https://wiki.dfrobot.com/SKU_DF2301QG-EN_Gravity_Voice_Recognition_Module_I2C_UART#target_4
// Nano pin 5V      DF2301QG VCC
// Nano pin GND     DF2301QG GND
// Nano pin D-10    DF2301QG UART TX (Nano RX) GREEN wire
// Nano pin D-12    DF2301QG UART RX (Nano TX) BLUE wire
//


#include "Arduino.h"

// WS2812B communications
#include <FastLED.h>

// DFRobot SKU DF2301QG-EN communications
#include "SoftwareSerial.h"                  // to talk to myDFPlayer without using up debug serial port
//#define ARDUINO_AVR_UNO 1  // fool library into using software serial
//#undef  ARDUINO_SAM_ZERO   // fool library into using software serial
#include "DFRobot_DF2301Q.h"
#include "DF2301QG_cmds.h" // my list of command ID codes

// How many leds in your strip?
#define NUM_LEDS 241 // Mark-MDO47 number of WS2812B LEDs

// For led chips like WS2812, which have a data line, ground, and power, you just
// need to define DATA_PIN.  For led chipsets that are SPI based (four wires - data, clock,
// ground, and power), like the LPD8806 define both DATA_PIN and CLOCK_PIN
// Clock pin only needed for SPI based chipsets when not using hardware SPI
#define DATA_PIN 7 // Mark-MDO47 we use pin 7 for LEDs
// #define CLOCK_PIN 13 // Mark-MDO47 we don't use CLOCK_PIN with this LED Strip

// DF2301QG voice command module definitions
#define DF2301QG_RX_PIN 10 // DF2301QG UART TX (Nano RX)
#define DF2301QG_TX_PIN 12 // DF2301QG UART RX (Nano TX)
/**
   @brief DFRobot_URM13_RTU constructor
   @param serial - serial ports for communication, supporting hard and soft serial ports
   @param rx - UART The pin for receiving data
   @param tx - UART The pin for transmitting data
*/
SoftwareSerial softSerial(/*rx =*/DF2301QG_RX_PIN, /*tx =*/DF2301QG_TX_PIN);
DFRobot_DF2301Q_UART asr(/*softSerial =*/&softSerial);


// Mark-MDO47 FastLED definitions
#define BRIGHTMAX 40 // set to 250 for MUCH brighter
#define FRAMES_PER_SECOND 120

#define PATTERN_MAX_NUM 5 // 0-5 are patterns

// Variables will change:
static uint8_t gHue = 0; // rotating "base color"

// Define the array of leds
CRGB leds[NUM_LEDS];

// constants won't change:

uint8_t gCurrentPatternNumber = 0; // Index number of which pattern is current

void rainbow() 
{
  // FastLED's built-in rainbow generator
  fill_rainbow( leds, NUM_LEDS, gHue, 7);
}

void rainbowWithGlitter() 
{
  // built-in FastLED rainbow, plus some random sparkly glitter
  rainbow();
  addGlitter(80);
}

void addGlitter( fract8 chanceOfGlitter) 
{
  if( random8() < chanceOfGlitter) {
    leds[ random16(NUM_LEDS) ] += CRGB::White;
  }
}

void confetti() 
{
  // random colored speckles that blink in and fade smoothly
  fadeToBlackBy( leds, NUM_LEDS, 10);
  int pos = random16(NUM_LEDS);
  leds[pos] += CHSV( gHue + random8(64), 200, 255);
}

void sinelon()
{
  // a colored dot sweeping back and forth, with fading trails
  fadeToBlackBy( leds, NUM_LEDS, 20);
  int pos = beatsin16( 13, 0, NUM_LEDS-1 );
  leds[pos] += CHSV( gHue, 255, 192);
}

void bpm()
{
  // colored stripes pulsing at a defined Beats-Per-Minute (BPM)
  uint8_t BeatsPerMinute = 62;
  CRGBPalette16 palette = PartyColors_p;
  uint8_t beat = beatsin8( BeatsPerMinute, 64, 255);
  for( int i = 0; i < NUM_LEDS; i++) { //9948
    leds[i] = ColorFromPalette(palette, gHue+(i*2), beat-gHue+(i*10));
  }
}

void juggle() {
  // eight colored dots, weaving in and out of sync with each other
  fadeToBlackBy( leds, NUM_LEDS, 20);
  uint8_t dothue = 0;
  for( int i = 0; i < 8; i++) {
    leds[beatsin16( i+7, 0, NUM_LEDS-1 )] |= CHSV(dothue, 200, 255);
    dothue += 32;
  }
}

// List of patterns to cycle through.  Each is defined as a separate function below.
typedef void (*SimplePatternList[])();
SimplePatternList gPatterns = { rainbow, rainbowWithGlitter, confetti, sinelon, juggle, bpm };
char * gPatternStrings[1+PATTERN_MAX_NUM] = { "0 rainbow", "1 rainbowWithGlitter", "2 confetti", "3 sinelon", "4 juggle", "5 bpm" };
int gPrevPattern = -1; // previous pattern number

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// handle_DF2301QG() - process DF2301QG voice command module data.
//    returns: pattern number 0 <= num <= PATTERN_MAX_NUM
//
int handle_DF2301QG() {
  int pattern = gCurrentPatternNumber; // integer pattern number from 0 thru 5 inclusive
  uint8_t CMDID;

  softSerial.listen();
  CMDID= asr.getCMDID(); // Get the ID for spoken command word; 0 means no command

  if ((DF2301QG_Display_number_zero <= CMDID) && (CMDID <= DF2301QG_Display_number_five)) {
    pattern = CMDID - DF2301QG_Display_number_zero;
    Serial.print(F("Set pattern ")); Serial.println(pattern);
  } else if (CMDID != 0) {
    Serial.print(F("DF2301QG cmd ID ")); Serial.println(CMDID);
  }
  return(pattern);
} // end handle_DF2301QG()

void setup() {
  // ## Clockless types ##
  FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS);  // GRB ordering is assumed
  FastLED.setBrightness(BRIGHTMAX); // help keep our power draw through Arduino Nano down

  Serial.begin(115200);         // this serial communication is for general debug; set the USB serial port to 115,200 baud
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  Serial.println(""); // print a blank line in case there is some junk from power-on

  // Init the DF2301QG voice command module
  while (!(asr.begin())) {
    Serial.println("Communication with device failed, please check connection");
    delay(3000);
  }

  softSerial.listen();
  // here if want to reset the DF2301QG voice command module
  // asr.resetModule();

  /* possible DF2301QG "SET" commands
     DF2301Q_UART_MSG_CMD_SET_VOLUME: Set volume, the set value range 1-7 
     DF2301Q_UART_MSG_CMD_SET_ENTERWAKEUP: Enter wake-up state; set value 0
     DF2301Q_UART_MSG_CMD_SET_MUTE Mute mode; set value 1: mute, 0: unmute
     DF2301Q_UART_MSG_CMD_SET_WAKE_TIME ; Wake-up duration; the set value range 0-255s
  */
  asr.settingCMD(DF2301Q_UART_MSG_CMD_SET_MUTE, 0);
  asr.settingCMD(DF2301Q_UART_MSG_CMD_SET_VOLUME, 7);
  asr.settingCMD(DF2301Q_UART_MSG_CMD_SET_WAKE_TIME, 20);

  // tell that DF2301QG voice command module is ready
  asr.playByCMDID(DF2301QG_Retreat);

  Serial.println("ArduinoClass init...");
}

void loop() {
  static uint32_t prevMillisec = 0;

  EVERY_N_MILLISECONDS( 100 ) { gCurrentPatternNumber = handle_DF2301QG(); }
  if (gPrevPattern != gCurrentPatternNumber) {
    gPrevPattern = gCurrentPatternNumber;
    Serial.println(gPatternStrings[gCurrentPatternNumber]);
  }

  // Call the current pattern function once, updating the 'leds' array
  gPatterns[gCurrentPatternNumber]();

  // send the 'leds' array out to the actual LED strip
  //if ((prevMillisec+1000/FRAMES_PER_SECOND) < millis() ) FastLED.show();  
  // insert a delay to keep the framerate modest
  // FastLED.delay(1000/FRAMES_PER_SECOND); 

  // do some periodic updates
  EVERY_N_MILLISECONDS( 20 ) { gHue++; } // slowly cycle the "base color" through the rainbow
}
